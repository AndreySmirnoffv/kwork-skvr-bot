import { v4 } from 'uuid';
import { checkout } from '../services/yookassa.js';
import pricesDb from '../db/prices/db.json' with { type: "json" };
import { PaymentModel } from '../models/paymentModel.js';
import { registerQuestions } from './registerQuestions.js';
import { createUser } from './users.js';
import { UserModel } from '../models/UserModel.js';
import { SubModel } from '../models/SubModel.js';
import { saveSubPrice } from './saveSubPrice.js';

const paymentModel = new PaymentModel();
let paymentIntervals = [];

export async function createPayment(bot, chatId, subType) {
    try {
        const {email} = await registerQuestions(bot, chatId)
        await new UserModel().updateUser({ chatId, email })

        console.info(`Creating payment for chatId: ${chatId}, subType: ${subType}`);

        const payload = {
            amount: {
                value: pricesDb[subType].price,
                currency: "RUB"
            },
            confirmation: {
                type: "redirect",
                return_url: "https://google.com"
            },
            receipt: {
                customer: {
                  email,
                },
                items: [
                  {
                    description: "–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –∫–∞–Ω–∞–ª –ø–æ –º–µ–¥–∏—Ç–∞—Ü–∏—è–º",
                    quantity: 1,
                    amount: {
                      value: pricesDb[subType].price,
                      currency: "RUB",
                    },
                  },
                ],
              },
        };

        const startDate = new Date();
        const endDate = new Date();
        endDate.setDate(startDate.getDate() + pricesDb[subType].durationInDays);

        const { id, confirmation: { confirmation_url }, status, paid } = await checkout.createPayment(payload, v4());

        const sentMessage = await bot.sendMessage(chatId, "–û–ø–ª–∞—Ç–∏—Ç—å –º–æ–∂–Ω–æ –ø–æ –∫–Ω–æ–ø–∫–µ", {
            reply_markup: {
                inline_keyboard: [
                    [{ text: "–û–ø–ª–∞—Ç–∏—Ç—å", url: confirmation_url }]
                ]
            }
        });

        setTimeout(async () => {
            await bot.deleteMessage(chatId, sentMessage.message_id);
            await bot.sendMessage(chatId, "–°—Ä–æ–∫ –æ–ø–ª–∞—Ç—ã –∏—Å—Ç–µ–∫ –ª–∏–±–æ —Ç—ã —É–∂–µ –æ–ø–ª–∞—Ç–∏–ª)")
        }, 600000); 
        await paymentModel.insertPayment({ paymentId: id, chatId, amount: pricesDb[subType].price, paid, status });
        console.info(`Payment created: ${id}, status: ${status}, paid: ${paid}`);

        setInterval(() => capturePayment(bot, chatId, id, subType), 3000);
    } catch (error) {
        console.error(`Error creating payment for chatId: ${chatId}, subType: ${subType}, error: ${error.message}`);
        console.error('Error creating payment:', error);
    }
}

export async function capturePayment(bot, chatId, paymentId, data) {
    try {
        console.info(`Capturing payment for paymentId: ${paymentId}, chatId: ${chatId}`);

        const { status, created_at, amount: { value }, paid } = await checkout.getPayment(paymentId);
        const payload = {
            amount: { 
                value,
                currency: "RUB"
            }
        }
        console.info(`Current payment status: ${status}, paymentId: ${paymentId}`);

        if (status === "succeeded") {
            clearInterval(paymentIntervals[paymentId]);
            return delete paymentIntervals[paymentId];

        }else if (status !== "waiting_for_capture" || (Date.now() - new Date(created_at).getTime()) > 600000) {
            clearInterval(paymentIntervals[paymentId]);
            return delete paymentIntervals[paymentId];
        }

        const captureResponse = await checkout.capturePayment(paymentId, payload, v4());
        if (captureResponse.status !== "succeeded") {
            return await bot.sendMessage(chatId, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –ø–ª–∞—Ç–µ–∂. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
        }

        await paymentModel.updatePaymentStatus({ chatId, status: captureResponse.status, paymentId, amount: value, paid });

        await succeedPayment(bot, chatId, paymentId, data);
    } catch (error) {
        console.error(`Error capturing payment for paymentId: ${paymentId}, chatId: ${chatId}, error:`, error);
        await bot.sendMessage(chatId, "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –ø–ª–∞—Ç–µ–∂. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.");
    }
}


export async function succeedPayment(bot, chatId, paymentId, data) {
    try {
        const { status, paid } = await checkout.getPayment(paymentId);

        if (status !== "succeeded") {
            console.warn(`Payment failed: paymentId: ${paymentId}, status: ${status}`);
            return await bot.sendMessage(chatId, "‚ùå –û–ø–ª–∞—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
        }

        await bot.sendMessage(chatId, "‚úÖ –í–∞—à–∞ –æ–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!");

        await paymentModel.updatePaymentStatus({
            paid,
            paymentId,
            status
        });

        let user = await new UserModel().findUser(chatId);

        if (!user) {
            const userInfo = await registerQuestions(bot, chatId);
            await createUser(chatId, userInfo);
        }

        const endDate = new Date();
        endDate.setMonth(endDate.getMonth() + 1);
        
        let currentSub = await new SubModel().getCurrentSub(chatId);
        
        if (!currentSub) {
            
            console.log(data)

            if (!data) {
                throw new Error('Invalid subscription type');
            }

            await new SubModel().createSub({
                chatId,
                status,
                type: data,
                price: pricesDb[data].price,  
                durationInDays: pricesDb[data].durationInDays,  
                endDate, 
            });
        
            await new UserModel().updateUser({ chatId, email });
        
            return await bot.sendMessage(chatId, `üìÖ –ü–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞ –¥–æ ${endDate.toLocaleDateString()}`, {
                reply_markup: {
                    inline_keyboard: [
                        [{ 
                            text: "–ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", 
                            url: process.env.CHANNEL_INVITE_LINK 
                        }]
                    ]
                }
            });
        }
        
        currentSub.setMonth(currentSub.getMonth() + 1);

        await new SubModel().updateCurrentSub(chatId, { endDate: currentSub });

        if (user.isBanned){
            await bot.unBanChatMember(process.env.CHANNEL_ID, chatId)
        }
        
        await saveSubPrice(chatId)

        return await bot.sendMessage(
            chatId,
            "–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–∏–Ω—è—Ç—å —É—Å–ª–æ–≤–∏—è –æ—Ñ–µ—Ä—Ç—ã, –ø–æ–ª–∏—Ç–∏–∫–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å —Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∫—É.",
            {
                reply_markup: {
                    inline_keyboard: [
                        [ {text: "–ü–æ–ª–∏—Ç–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö", url: "https://disk.yandex.ru/i/XW-id3g7CgUySQ"} ]
                        [{ text: "–û—Ñ–µ—Ä—Ç–∞", url: "https://disk.yandex.ru/i/6Ht9fMgHzYWBjg"}]
                        [{ text: "–ü—Ä–∏–Ω—è—Ç—å", callback_data: "accept_terms" }]
                    ],
                },
            }
        );
                 
        
    } catch (error) {
        console.error(`Error succeeding payment for paymentId: ${paymentId}, chatId: ${chatId}, error: ${error.message}`);
        console.error('Error succeeding payment:', error);
    }
}
